Модули и функции
================

Модули
------

Модуль - это группа логически связанных функций, объединенных под одним именем. Грубо говоря, модули в Erlang - это аналог пространств имен из императивных языков. Ини используются для того, что бы объединить функции имеющие сходное назначение. На примет функции дял работы со списками находятся в модуле `lists`, а фнкции ввода-вывода в модуле `io`.

Для того, что бы вызвать функцию, необходимо воспользоваться следующей конструкцией: `ModuleName:FunctionName(Arg1, Arg2, ..., ArgN)`. Для примера вызовем функцию, которая возвращает элемент переданного кортежа с указанным номером. Эта функция называется `element` и находится в модуле `erlang`.
```erlang
1> erlang:element(3, {23,54,34,95}).
34
```
Так же есть возможность вызывать функции без явного указания модуля. Об этом написанно немного дальше.

###Структура модуля

Модуль содержит в себе функции и аттрибуты. 
Аттрибуты - это не переменные, как в импертивных языках. В Erlang аттрибуты модуля - это его метаданные, такие как название, версия, автор, список импортированных фнкций и т.д. Аттрибуты используются компилятором. Так же из них человек может получить полезную информацию о модуле без необходимости разбираться в исходном коде.

Аттрибуты указываются в самом начале файла с модулем и имеют следующий вид: `-Name(Arg).`. Название модуля должно быть атомом. Каждый аттрибут указывается на отдельной строке.

Вы можете присвоить модулю любые аттрибуты, которые захотите, например настроение, которое было у вас во время его написания. Так же есть ряд предопределенных аттрибутов. И сейчас мы сможем рассмотреть самые частоиспользуемые. Для наглядности мы создадим модуль, который будет содержать функции, выполняющие самые элементарные математические операции: сложение, вычитание, умножение и деление.

**-module(Name).**  
Название модуля - это единственный обязательный аттрибут и он обязательно должен быть указан первым. Без него ваш модуль просто напросто не скомпилируется. В качестве оргумента принимает атом - название модуля. Назовем наш модуль `mySuperModule`.
```erlang
-module(mySuperModule).
```
Теперь мы емеем вполне работоспособный модуль. Мы объявили единственный обязательный аттрибут и теперь наш модуль может быть скомпилировн. Правда он абсолютно бесполезен, ведь в нем нет ни одной функции. Но фактически - это готовый модуль.

**-export([Fnct1/Arity, Fnct2/Arity, ..., FnctN/Arity])**  
Список экспортируемых функций - список функций модуля, которые будут доступны извне. Принимаемый аттрибут - список функций. Здесь `FnctN` - название функции, а `Arity` - колличество аргументов, принимаемых ей (арность). Наш модуль будет експортировать четыре функции: `add`, `subtr`, `mult`, `divis` (сложение, вычитание, умножение, деление). Каждая функция будет принимать по два аргумента.
```erlang
-export([add/2, subtr/2, mult/2, divis/2]).
```
Помните, что вункции, которые вы не укажете в списке экспорта будет невозможно вызвать извне модеуля. Работать с ними можно будет только внутри модуля.
Экспорт является средством достижения инкапсуляции в модуле. Как вы могли догадаться, экспортированные функции - это аналог открытых методов класса из императивных языков, а остальные - аналог закрытых.

**-import(ModuleName, [Fnct1/Arite, Fnct2/Arity, ..., FnckN/Arity]).**  
Этот аттрибут указывает, что мы хотим импортировать из модуля `ModuleName` функции указанные в списке, который передается вторым аргументом. Каждый импортируемый модуль указывается в отдельном аттрибуте.

Зачем импортировать функции. как упомяналось выше, дял обращения к функции из другого модуля нобходимо указать ее полное имя вида `ModuleName:FunctionName()`. Если вы не хотите каждый раз указывать имя модуля, его нужно импортировать. Этот аттрибут - аналог директивы `#using` из языка C++. Но не стоит злоупотреблять импортированием. Полное имя функции гораздо нагляднее. увидев его можно сразу сказать к какому модулю принадлежит вызываемая функция. В случае короткого имени, вам придется запоминать из какого модуля была импортированна эта функция.

Итак, наш модуль будет выводить результат выражения в консоль. Для этого мы будем использовать функцию `io::format/1`. Обычно мы будем использовать полные имена функций, но сейчас для примера давайте импортируем модуль `io`.
```erlang
-import(io, [format/1]).
```

Ну и для примера давайте укажем какой-нибудь произвольный аттрибут. Пусть это будет имя автора.
```erlang
-author("Haru Atari").
```

Функции
-------  
