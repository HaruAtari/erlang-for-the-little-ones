Типы данных, переменные, списки и кортежи
=========================================

Числа
-----

Erlang поддерживает два типа численных переменных: целочисленные и числа с плавающей точкой. Над числами можно производить такие математические операции как сложение, вычитание, умножение и деление:
```erlang
1> 7 + 3.
10
2> 12 - 4.
8
3> 5 * 2.
10
4> 12 / 6
2.0
5> 7 div 3.
2
6> 7 rem 3.
1
```
Обратите внимание, что результатом деления было число с плавающей точкой. Erlang достаточно умен, что бы автоматически приводить численные переменные к нужному типу.

Так же Erlang позволяет производить несколько операций за раз. Математические операции подчиняются стандартным правилам приоритета. Поэтому результатом выражения `2 + 3 * 4.` будет 14, потому что умножение имеет более высокий приоритет, чем сложение. Для того, что бы явно задать порядок вычислений нужно использовать скобки:
```erlang
1> (2 + 3) * 4.
20
2> -(10 + 3).
-13
```
К тому же, вы не обязаны ограничиваться только десятичной системой счисления. Вы можете использовать числа с любым основанием от 2 до 36. Для этого число необходимо указывать в виде `Base#Value`.
```erlang
1> 2#11011.
27
2> 10#1198.
1198
3> 16#A04F.
41295
4> 36#1TA.
2350
```
Но и это еще не все. В Erlang вы можете использовать числа с разными основаниями в одном выражении:
```erlang
1> 2#11011 + 36#1TA.
2377
2> 10#1198 - 16#A04F.
-39841
3> 3#201 * 4#321.
1083
```

Атомы
-----

Атомы — это аналог именованных констант из других языков, причем значение атома в точности соответсвует его названию. Грубо говоря, атом — это строка, которую нельзя изменить.

Атомы должны начинаться со строчной буквы и могут содержать в себе строчные и заглавные буквы, цифры, знак подчеркивания(`_`) и собаку(`@`). Так же атом можно заключить в одинарные кавычки и тогда он может включать в себя любые символы. Ну и конечно же атом не может совпадать с зарезервированным словом. Поэтому названия атомов `after`, `and`, `andalso`, `band`, `begin`, `bnot`, `bor`, `bsl`, `bsr`, `bxor`, `case`, `catch`, `cond`, `div`, `end`, `fun`, `if`, `let`, `not`, `of`, `or`, `orelse`, `query`, `receive`, `rem`, `try`, `when`, `xor` недопустимы.
```erlang
1> atom.
atom
2> otherAtom.
otherAtom
3> atom_with_underscore.
atom_with_underscore
4> one@more@atom.
one@more@atom
5> 'Atom with whitespace'.
'Atom with whitespace'
6> ' Atom with special charactes #^&?'.
' Atom with special charactes #^&?'
7> Atom.
* 1: variable 'Atom' is unbound
8> after.
* 1: syntax error before: 'after'
```

Логические типы данных и операторы сравнения
--------------------------------------------

Булевы типы данных в Erlang — это два зарезервированных атома: `true` и `false`. 
С этим связан один любопытный и неочевидный факт. Но об этом чуть позже.

В языке реализованы все основные логические операции такие как «и»(`and`), «или»(`or`), «исключающее или»(`xor`) и «отрицание»(`not`).
```erlang
1> true or false.
true
2> true and false.
false
3> true xor false.
true
4> not false.
true
5> (not (true xor true)) or (false and true).
true
```
Операторы `and` и `or` всегда вычисляют значения выражений с обеих сторон от себя. Поэтому при выполнении кода `(1 > 2) or (3 < 4).` будут найдены значения обоих выражений, хотя после вычисления правого выражения результат уже известен. Если вы хотите избежать этого, используйте операторы `andalso` и `orelse`.

Для сравнения значений между собой используются операторы «равно»(`==`), «соответсвенно равно»(`=:=`), «соответственно неравно»(`=/=`), «неравно»(`/=`), «меньше»(`<`), «меньше или равно»(`=<`), «больше»(`>`) и «больше или равно»(`>=`).
```erlang
1> 2 == 2.0.
true
2> 2 =:= 2.0.
false
3> 3 /= 3.0.
false
4> 3 =/= 3.0.
true
5> 5 > 5.
false
6> 5 =< 5.
true
```
Если вы раньше программировали на других языках, то, скорее всего, привыкли, что в них true равно 1, а else равно 0. В Erlang это правило не работает:
```erlang
1> true == 1.
false
2> false == 0.
false
3> false > 19. %% !!!
true
```
Обратили внимание на третью строку? Странно, неправда ли? А все дело в том, что Erlang позволяет сравнивать значения разных типов и при сравнении руководствуется следующим правилом: **число(number) < атом(atom) < ссылка(reference) < функция(fun) < порт(port) < процесс(pid) < кортеж(tuple) < список(list) < битовая строка(bit string)**. Выше мы говорили, что true и false — атомы, а из приведенного выражения видно, что атомы «больше» чисел. Поэтому и получается, что `false > 19.`.

Переменные
----------

В чистых функциональных языках(таких как Haskell) не существует переменных. Erlang же позволяет нам создавать переменные, но с одним ограничением: значение переменной может быть присвоено только один раз. Повторное присвоение значения вызовет ошибку.

Имя переменной должно начинаться с заглавной буквы или знака подчеркивания(`_`). Имя переменной может состоять из одного только знака подчеркивания. Но переменная с таким именем не запоминает значение. Такие переменные используются для сопоставления с образцом (об этом смотрите далее).
```erlang
1> Variable = 10 - 7.
3
2> OtherVariable = 3 * 4.
12
3> _result = Variable + OtherVariable.
15
4> _result.
15
5> Variable = 5.
** exception error: no match of right hand side value 5
```

Кортежи
-------
Иногда группу переменных, которые каким-либо образом связаны между собой, удобнее хранить вместе. Для этого Erlang предоставляет такую конструкцию, как кортеж. Кортеж имеет следующий вид: `{Value1, Value2, ..., ValueN}` и может содержать любое количество значений.

Давайте рассмотрим на примере, как можно использовать кортежи. Довольно заезженный пример: нам необходимо хранить информацию о точке на координатной плоскости (координаты X и Y). Мы могли бы завести две отдельных переменных и хранить координаты в них, но ведь проще хранить их вместе.
```erlang
1> MyPoint = {2,5}.
{2,5}
```
Как указано выше, размер кортежа не ограничивается двумя значениями. Так же кортеж может содержать значения разных типов, в том числе и другие кортежи.
```erlang
1> MyTuple = {1,myAtom,true,{1,false}}.
{1,myAtom,true,{1,false}}
```
