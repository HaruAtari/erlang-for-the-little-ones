Система типов
=============

Если вы читали прошлые главы, то, скорее всего, обратили внимание, что мы нигде не указывали типы переменных и возвращаемых функциями данных. Так же мы не указывали тип данных при сопоставлении с образцом. Например, кортеж `{A, B}` может принимать значение `{someAtom, 100}`, `{100.0, "Some string"}` и т.д.

Если данные будет невозможно сопоставить с указанным образцом, будет сгенерированна ошибка. Это произойдет непосредственно в момент выполнения кода. Это происходит потому что Erlang - **динамически типизированный** язык. Компилятор не может отловить все ошибки на этапе компиляции. Поэтому многие ошибки генерируются во время выполнения программы.

Почему Erlang не имеет статической типизации? Немало копий было сломано в спорах о том, какая типизация лучше: статическая или динамическая. У каждой есть свои плюсы и минусы. Один из главных минусов динамической типизации - невозможность поиска ошибок, связанных с типами, на этапе компиляции. Из-за этого эти ошибки возникают в рантайме и программа "падает", что снижает общую надежность программного продукта. Но Erlang решает эту проблему другим, более эффективным способом.

Идеалогия Erlang: "Если оно сломалось - пусть ломается". Язык обладает инструментами, позволяющими изолировать и корректно обрабатывать все ошибки, которые могут возникнуть. Это делает программы на Erlang очень живучими. Классический пример живучести программ на Erlang, который приводят - ПО комутаторов Ericsson AXD 301 ATM. Этот продукт имеет больше миллиона строк кода и аптайм 99.9999999%. Впечатляет.

В общем, Erlang не стремиться избегать ошибок. Он предлагает правильно их обрабатывать.

Так же Erlang относится к языкам с **сильной типизацией**. Это значит, что приведения типов нужно производить явно. Если мы будет использовать в одном выражении несовместимые типы данных, то получим ошибку:
```erlang
1> 10 - "5".
** exception error: bad argument in an arithmetic expression
    in operator  -/2
        called as 10 - "5"
```
Для преобразования типов язык предоставляет ряд функций.

Преобразование типов
--------------------
