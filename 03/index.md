Базовый синтаксис функций
=========================

В прошлой главе мы рассмотрели как объявлять функции и как объединять их в модули. В этой главе мы рассмотрим синтаксис функций более подробно.

Сопоставление с образцом
------------------------

Для начала давайте напишем функцию, которая будет приветствовать пользователя и текст приветствия будет зависеть от его пола. В виде псевдокода наша функция будет выглядеть слудующим образом:
```
function greet(Gender,Name)
  if Gender == male then
    print("Hello, Mr. %s!", Name)
  else if Gender == female then
    print("Hello, Mrs. %s!", Name)
  else
    print("Hello, %s!", Name)
end
```
Если вместо классической конструкции `if then else` использовать сопоставление с образцом, можно сэкономить кучу шаблонного кода. Вот так эта функция будет выглядеть на Erlang если использовать сопоставление с образцом:
```erlang
greet(male, Name) -> 
    io:format("Hello, Mr. ~s!", [Name]);
greet(female, Name) ->
    io:format("Hello, Mrs. ~s!", [Name]).
```
Функция `io:format` используется для форматированного вывода в терминал. Здесь мы использовали сопоставление с образцом в описании списка аргументов функции. Это позволило нам одновременно присвоить входные значения и выбрать ту часть функции, которая должна быть выполнена. Зачем сначала присваивать значения, а потом сравнивать их в теле функции, если можно сделать это одновременно и в "более декларативном" стиле?

В общем виде объявление такой функции выглядит следующим образом:
```erlang
fnct_name(X) ->
  Extpression;
fnct_name(Y) ->
  Expression;
fnct_name(_) ->
  Expression.
```
Каждая ветвь функции объявляется как полноценная функция но заканчивается точкой с запятой(`;`), следом за ней объявляется следующая. После последней части ставиться точка.

Обратите внимание на послений образец. Что будет, если мы вызовем нашу функцию `greet` и укажем непредусмотренный пол? Мы получим исключение о том, что входные параметры не подходят ни под один из образцов:
```erlang
1> chapter03:greet(someOther, "Haru").
** exception error: no function clause matching chapter03:greet(someOther, "Haru")
```
Поэтому важно включать в объявление образец, который подойдет под любое значение. При этом он должен быть последним. В противном случае образцы объявленные после него никогда не будут обработаны.
Давайте перепишем нашу функцию, так что бы она корректно обрабатывала неверные входные значения:
```erlang
greet(male, Name) ->
    io:format("Hello, Mr. ~s!", [Name]);
greet(female, Name) ->
    io:format("Hello, Mrs. ~s!", [Name]);
greet(_, Name) ->
    io:format("Hello, ~s!", [Name]).
````
 
Но сопоставление с образцом в объявлении функций приносит намного больше пользы, чем просто сокращение объема кода. Вспомним списки: список состоит из головы и остальной части. Давайте напишем две функции, которые будут возвращать первый и второй элементы полученного списка.
```erlang
first([X|_]) -> 
    X.
second([_,X|_) -> 
    X.
```
Достаточно просто, не так ли? Есть еще один интересный прием, основанный на том факте, что переменные в Erlang можно присвоить только один раз. 
```erlang
same(X,X) ->
    true;
same(_,_) ->
    false.
```
Эта функция возвращает `true`, если ее аргументы одинаковы, иначе возвращает `false`. Как это работает? При вызове функции `chapter03::same(one, two).` переменной `X` присваивается значение `one`, затем производится попытка присвоить этой же переменной значение `two`. Из-за того, что значение уже было присвоено, попытка заканчивается неудачей и шаблон отбрасывается как неподходящий. Так как во втором случае мы не указываем явно каким переменным нужно присвоить значения, шаблон подходит и функция возвращает `false`. Если же передать в функцию одинаковые занчения `chapter03:same(3, 3).`, то первый шаблон подойдет и функция вернет `true`.


Охранные выражения
------------------

У сопоставления с образцом есть один большой недостаток: оно недостаточно выразительно. С его помощью нельзя указать тип данных, диапазон и другие подобные обобщения. Каждый образец является конкретным случаем. Для решения этой проблемы в Erlang есть Охранные выражения (или сторожевые условия). Для начала давайте напишем функцию, которая будет принимать наш ИМТ (индекс массы тела) и оценивать наше состояние. ИМТ человека равен его весу разделенному на квадрат роста.
```erlang
bmi_tell(Bmi) when Bmi =< 18.5 ->
    "You're underweight.";
bmi_tell(Bmi) when Bmi =< 25 ->
   "You're supposedly normal.";
bmi_tell(Bmi) when Bmi =< 30 ->
   "You're fat.";
bmi_tell(_) ->
    "You're very fat.".
```
Здесь при обращении к функции происходит проверка первого условия, находящегося после слова `when` (`Bmi =< 18.5`). Если это выражение возвращает `true` будет выполнена соответствующая ветвь кода. Иначе происходит проверка следующего условия и так до конца. И тут мы тоже добавили в конец условие, под которое подойдет любое значение.

В общем случае объявление функции с использованием охранных выражений выглядит следующим образом:
```erlang
fnct_name(Arg_1, Arg_1, ..., Arg_n) when rule_1 ->
    Expression;
fnct_name(Arg_1, Arg_1, ..., Arg_n) when rule_2 ->
    Expression.
```
Так же мы не ограничены одним выражением в условии. Мы можем провести несколько проверок. Если для прохождения проверки должны быть выполнены оба условия (аналог `andalso `), между ними ставится запятая(`,`).
```erlang
lucky_number(X) when 10 < X, X > 20 ->
    true;
lucky_number(_) ->
    false.
```
Если достаточно хотя бы одного (аналог `orelse`), они разделяются точкой с запятой(`;`).
```erlang
lucky_atom(X) when X == atom1; X == anot2 ->
    true;
lucky_number(_) ->
    false.
```
В охранных выражениях можно использовать функции. Вот функция, которая делит одно число на другое, но перед этим проверяет, что бы переданные агрументы были числами и что бы `Y` не был равен нулю:
```erlang
safe_division(X, Y) when is_integer(X), is_integer(Y), Y /= 0 ->
    X / Y;
safe_division(_, _) ->
    false.
```
