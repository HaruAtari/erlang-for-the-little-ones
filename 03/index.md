Базовый синтаксис функций
=========================

В прошлой главе мы рассмотрели как объявлять функции и как объединять их в модули. В этой главе вы рассмотрим синтаксис функций более подробно.

Сопоставление с образцом
------------------------

Для начала давайте напишем функцию, которая будет приветствовать пользователя и текст приветствия будет зависеть от его пола. В виде псевдокода наша функция будет выглядеть слудующим образом:
```
function greet(Gender,Name)
  if Gender == male then
    print("Hello, Mr. %s!", Name)
  else if Gender == female then
    print("Hello, Mrs. %s!", Name)
  else
    print("Hello, %s!", Name)
end
```
Если вместо классической конструкции `if then else` использовать сопоставление с образцом, можно сэкономить кучу шаблонного кода. Вот так эта функция будет выглядеть на Erlang если использовать сопоставление с образцом:
```erlang
greet(male, Name) -> 
    io:format("Hello, Mr. ~s!", [Name]);
greet(female, Name) ->
    io:format("Hello, Mrs. ~s!", [Name]).
```
Функция `io:format` используется для форматированного вывода в терминал. Здесь мы использовали сопоставление с образцом в описании списка аргументов функции. Это позволило нам одновременно присвоить входные значения и выбрать ту часть функции, которая должна быть выполнена. Зачем сначала присваивать занчения, а потом сравнивать их в теле функции, если можно сделать это одновременно и в "более деларативном" стиле?

В общем виде объявление такой функции фыглыдит следующим образом:
```erlang
fnct_name(X) ->
  Extpression;
fnct_name(Y) ->
  Expression;
fnct_name(_) ->
  Expression.
```
Каждая ветвь функции объявляется как полноценная функция но заканчивается точкой с запятой, следом за ней объявляется следующая. После последней части ставиться точка.

Обратите внимание на послений образец. Что будет, если мы вызовим нашу функцию `greet` и укажем непредусмотренный пол? Мы полчим исключение о том, что входные параметры не подходят ни под один из образцов:
```erlang
1> chapter03:greet(someOther, "Haru").
** exception error: no function clause matching chapter03:greet(someOther, "Haru")
```
Поэтому важно включать в объявление образец, который подойдет под любое значение. При этом он должен быть последним. В противном случае образцы объявленные после него никогда не будут обработаны.
Давайте перепишем нашу функция, так что бы она корректно обрабатывала неверные входные значения:
```erlang
greet(male, Name) ->
    io:format("Hello, Mr. ~s!", [Name]);
greet(female, Name) ->
    io:format("Hello, Mrs. ~s!", [Name]);
greet(_, Name) ->
    io:format("Hello, ~s!", [Name]).
````
 
Но сопоставление с образцом в объявлении функций приносит намного больше пользы, чем просто сокращение объема кода. Вспомним списки: список состоит из головы и остальной части. Давайте напишем две функции, которые будут возвращать первый и второй элементы полученного списка.
```erlang
first([X|_]) -> 
    X.
second([_,X|_) -> 
    X.
```
Достаточно просто, не так ли? Есть еще один интересный прием, основанный на том факте, что переменные в Erlang можно присвоить только один раз. 
```erlang
same(X,X) ->
    true;
same(_,_) ->
    false.
```
Эта функция возвращает `true`, если е аргументы одинаковы, иначе возвращает false. Как это работает? При вызове функции `chapter03::same(one, two).` переменной `X` присваивается значение `q`, затем производится попытка присвоить этой же переменной значение `2`. Из-за того, что значение уже было присвоено, попытка заканчивается неудачей и шаблон отбрасывается как неподходящай. Так как во втором случае мы не указываем явно каким переменным нужно присвоить значения, шаблон подходит в функция возвращает `false`. Если же передать в функцию одинаковые занчения `chapter03:same(3, 3).`, то первый шаблон подойдет и функция вернет `true`.





